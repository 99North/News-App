=======================================================RUN IT IN DOCKER EC2 MACHINE===============================================================================
=>Run these command to install aws cli and creating ecr and login into ecr as docker login
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"   :run it in home/ubuntu/ directory or as you wish in other directory
unzip awscliv2.zip
./aws/install
aws --version
aws configure : here provide your aws access key, secret key & region
aws sts get-caller-identity   : to verify the aws configuration
aws ecr create-repository --repository-name news-app/frontend --region ap-south-1
aws ecr create-repository --repository-name news-app/backend --region ap-south-1
aws ecr get-login-password --region ap-south-1 | docker login --username AWS --password-stdin <your_aws_account_id>.dkr.ecr.ap-south-1.amazonaws.com     :to docker login



==================================================================================================================================================================
=>Now create a Dockerfile in  News-App/frontend  and paste this code bellow
# ---- Stage 1: Build React app ----
FROM node:20-slim AS builder

WORKDIR /app

# Copy package files first
COPY package*.json ./

# Install dependencies
ENV NODE_ENV=production
RUN npm install

# Copy full source
COPY . .

# Build React app (build-time env vars optional)
RUN npm run build

# ---- Stage 2: Serve using Nginx ----
FROM nginx:alpine

# Copy build output
COPY --from=builder /app/build /usr/share/nginx/html

# Copy the runtime env config template
COPY public/env-config.js /usr/share/nginx/html/env-config.js

# Install envsubst for variable replacement
RUN apk add --no-cache gettext

# Expose port
EXPOSE 80

# Replace env vars in env-config.js at container startup
CMD ["/bin/sh", "-c", "envsubst < /usr/share/nginx/html/env-config.js > /usr/share/nginx/html/env-config.js && nginx -g 'daemon off;'"]


=>Now run this command inside   News-App/frontend folder to build docker image & tag it & push to ECR
docker build -t news-frontend:latest 
docker tag news-frontend:latest <your_aws_account_id>.dkr.ecr.ap-south-1.amazonaws.com/news-app/frontend:latest    : to tag docker image 
docker push <your_aws_account_id>.dkr.ecr.ap-south-1.amazonaws.com/news-app/frontend:latest     :to push the image to aws ecr



ALTERNATIVE WAY
NOTE: If you are using docker login then run these commands
docker login -u <docker_username>
docker build docker build -t news-frontend:latest .
docker tag news-frontend:latest systemail150/news-frontend:latest
docker push systemail150/news-frontend:latest

===================================================================================================================================================================
=>Now create a Dockerfile inside   News-App/backend and paste this code
# server/Dockerfile
FROM node:20-slim

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

EXPOSE 3001
CMD ["node", "app.js"]

=>Now run this to build a docker image from the Dockerfile & tage it & push to ECR
docker build -t news-backend:latest .   
docker tag news-backend:latest 144631842666.dkr.ecr.ap-south-1.amazonaws.com/news-app/backend:latest
docker push 144631842666.dkr.ecr.ap-south-1.amazonaws.com/news-app/backend:latest



ALTERNATIVE WAY
NOTE: If you are using docker login then run these commands
docker login -u <docker_username>
docker build docker build -t news-backend:latest .
docker tag news-backend:latest systemail150/news-backend:latest
docker push systemail150/news-backend:latest




========================================================RUN IT IN KUBERNETES EC2 MACHINE===========================================================================

=>Now install kubernetes in another ec2 instance & run these command bellow 
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"   :run it in home/ubuntu/ directory or as you wish in other directory
unzip awscliv2.zip
./aws/install
aws --version
aws configure : here provide your aws access key, secret key & region
aws sts get-caller-identity   : to verify the aws configuration

kubectl create secret docker-registry ecr-secret   --docker-server=144631842666.dkr.ecr.ap-south-1.amazonaws.com   --docker-username=AWS   --docker-password=$(aws ecr get-login-password --region ap-south-1)kubectl get secrets | grep ecr   : to see the secret is created or not

kubectl get secret ecr-secret -o yaml   : to verify the secret is created or not  and you can use this secret in backend-deployment.yaml file




====================================================================================================================================================================
=>Now setup kubernetes and craete a folder for persisten volume storage for postgresSQL
mkdir -p /mnt/data/postgres
chmod 777 /mnt/data/postgres


# ==========================
# ðŸ’½ 1. Persistent Volume
# ==========================
apiVersion: v1
kind: PersistentVolume
metadata:
  name: postgres-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: manual
  hostPath:
    path: /mnt/data/postgres

---
# ==========================
# ðŸ’¾ 2. Persistent Volume Claim
# ==========================
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: manual

---
# ==========================
# ðŸ—„ï¸ 3. ConfigMap for init.sql
# ==========================
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-initdb
data:
  init.sql: |
    -- Users Table
    CREATE TABLE IF NOT EXISTS users (
      id SERIAL PRIMARY KEY,
      username VARCHAR(50) UNIQUE NOT NULL,
      email VARCHAR(100) UNIQUE NOT NULL,
      password VARCHAR(255) NOT NULL,
      first_name VARCHAR(50),
      last_name VARCHAR(50),
      role VARCHAR(20) DEFAULT 'user',
      is_active BOOLEAN DEFAULT true,
      last_login TIMESTAMP,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    -- Articles Table
    CREATE TABLE IF NOT EXISTS articles (
      id SERIAL PRIMARY KEY,
      title VARCHAR(255) NOT NULL,
      description TEXT,
      section VARCHAR(100) NOT NULL,
      content TEXT NOT NULL,
      tag VARCHAR(100),
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      author_id INTEGER REFERENCES users(id),
      is_published BOOLEAN DEFAULT true
    );

---
# ==========================
# ðŸ˜ 4. Postgres Deployment
# ==========================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
        - name: postgres
          image: postgres:16
          ports:
            - containerPort: 5432
          env:
            - name: POSTGRES_DB
              value: newsdb
            - name: POSTGRES_USER
              value: debi
            - name: POSTGRES_PASSWORD
              value: debipass123
          volumeMounts:
            - name: postgres-storage
              mountPath: /var/lib/postgresql/data
            - name: initdb
              mountPath: /docker-entrypoint-initdb.d/
      volumes:
        - name: postgres-storage
          persistentVolumeClaim:
            claimName: postgres-pvc
        - name: initdb
          configMap:
            name: postgres-initdb

---
# ==========================
# ðŸŒ 5. Postgres Service
# ==========================
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
spec:
  selector:
    app: postgres
  ports:
    - port: 5432
      targetPort: 5432
  type: ClusterIP


=============================================================================================================================================================================================================================
=>Now create backend-deployment.yaml & paste this code & apply it.  So that Backend will automatically connect to:  postgres-service:5432     & will be reachable by frontend as:       http://backend-service:3001

# ==========================
# ðŸ§© 1. ConfigMap
# ==========================
apiVersion: v1
kind: ConfigMap
metadata:
  name: backend-config
data:
  DB_HOST: postgres-service
  DB_PORT: "5432"
  DB_NAME: newsdb
  JWT_EXPIRES_IN: "24h"
  FRONTEND_URL: "http://frontend-service"

---
# ==========================
# ðŸ” 2. Secret
# ==========================
apiVersion: v1
kind: Secret
metadata:
  name: backend-secret
type: Opaque
stringData:
  DB_USER: "debi"
  DB_PASSWORD: "debipass123"
  JWT_SECRET: "419461bae0350d7058bbb6629f88813c9dfd5498da471466c64caa4e14269c2b27e681f8897c6bf2664fa9bd22408cc0c0937728d13201aff27080dcf8f37d56"

---
# ==========================
# ðŸ±â€ðŸ’» 3. Deployment
# ==========================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      imagePullSecrets:
        - name: ecr-secret
      containers:
        - name: backend
          image: systemail150/news-backend:latest     
          ports:
            - containerPort: 3001
          envFrom:
            - configMapRef:
                name: backend-config
            - secretRef:
                name: backend-secret
          resources:
            limits:
              memory: "512Mi"
              cpu: "500m"
            requests:
              memory: "256Mi"
              cpu: "250m"

---
# ==========================
# ðŸŒ 4. Service
# ==========================
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  selector:
    app: backend
  ports:
    - port: 3001
      targetPort: 3001
      nodePort: 32001
  type: NodePort




=================================================================================================================================================
=>Create a file name   frontend-deployment.yaml & paste it

# ==========================
# ðŸ§© 1. ConfigMap
# ==========================
apiVersion: v1
kind: ConfigMap
metadata:
  name: frontend-config
data:
  REACT_APP_API_URL: "http://backend-service:3001"

---
# ==========================
# ðŸ±â€ðŸ’» 2. Deployment
# ==========================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      imagePullSecrets:
        - name: ecr-secret
      containers:
        - name: frontend
          image: systemail150/news-frontend:latest  
          ports:
            - containerPort: 80
          envFrom:
            - configMapRef:
                name: frontend-config

---
# ==========================
# ðŸŒ 3. Service
# ==========================
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
spec:
  selector:
    app: frontend
  ports:
    - port: 80
      targetPort: 80
  type: NodePort





kubectl apply -f frontend-deployment.yaml
kubectl apply -f backend-deployment.yaml
kubectl apply -f postgres-deployment.yaml


=>To check everything is working or not run this command
kubectl get all --all-namespaces

=>Now run this in kubernetes ec2 container to add a user to the users table
curl -X POST http://52.66.27.150:32001/auth/register \
-H "Content-Type: application/json" \
-d '{ "username": "debi", "email": "debi@gmail.com", "password": "debipass", "firstName": "Debi", "lastName": "Prasad" }'

=>To enter inside the postgres pod to check users table is created or not & data is inside or not 
kubectl exec -it   <postegres-pod-name>  -- bash
psql -U debi -d newsdb
\dt
SELECT * FROM users;




=>NOTE & REMEMBER ALWAYS
If database related anything went wrong then first delete deployement, pv, pcs, secret, configmap,svc   & MOST IMPORTANT run this:   rm -rf /mnt/data/postgres/*


