=>Run AkrutiMedia app inside docker steps
=>First run postgres-db container then backend then frontend container

=>Change the eslint version in /frontend/package.json to  
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "eslint": "^8.57.0",
    "eslint-config-react-app": "^7.0.1",
    "eslint-plugin-react": "^7.37.5",
    "globals": "^16.5.0"
  }


=>Go inside frontend/src/context/AuthContenxt.jsx and check this line is exist or not  if not then update it as bellow
const API_BASE_URL =
  (window._env_ && window._env_.REACT_APP_API_URL) ||
  process.env.REACT_APP_API_URL ||
  '/api';

=>Go inside src/services/articleServices.js   and check this line exist or not if not then update it as bellow
const API_BASE_URL =
  (window._env_ && window._env_.REACT_APP_API_URL) ||
  process.env.REACT_APP_API_URL ||
  '/api';


=>Now create a nginx.conf file in /frontend folder & paste this code
server {
    listen 80;
    server_name akrutimedia.com www.akrutimedia.com;

    root /usr/share/nginx/html;
    index index.html;

    # React Router support
    location / {
        try_files $uri /index.html;
    }

    # API proxy
    location /api/ {
        proxy_pass http://backend:3001/;  # <-- backend container name
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    # Cache static assets
    location /static/ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Error pages fallback
    error_page 404 /index.html;
}


=>Now create a .env file inside /frontend folder & past the code
#REACT_APP_API_URL=/api
REACT_APP_API_URL=https://akrutimedia.com/api





=>Now update the .env-prod file inside /backend folder as this bellow
# Database Configuration for development environment, make sure to update these values as per your local setup -RKS
DB_USER=debi
DB_PASSWORD=9090
DB_HOST=postgres-db
DB_PORT=5432
DB_NAME=akrutidev

# Note: JWT Configuration generate it using any online tool or library -RKS
JWT_SECRET=419461bae0350d7058bbb6629f88813c9dfd5498da471466c64caa4e14269c2b27e681f8897c6bf2664fa9bd22408cc0c0937728d13201aff27080dcf8f37d56
JWT_EXPIRES_IN=24h

# Server Port
PORT=3001

#FRONTEND_URL=http://65.2.150.166
FRONTEND_URL=https://akrutimedia.com



=>Now create a Dockerfile in /backend folder and paste this code
# server/Dockerfile
FROM node:20-slim

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .


EXPOSE 3001
CMD ["node", "app.js"]

=>run this command inside /backend folder:  docker build -t backend-app .
=>run this command to create a container:  docker run -d  -p 3001:3001 --network akruti-network --env-file .env-prod  --name backend backend-app





=>Now create a Dockerfile inside /frontend folder and paste this code
# ==========================
# Stage 1: Build React App
# ==========================
FROM node:20-slim AS builder
WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

# Build production bundle
RUN npm run build

# ==========================
# Stage 2: Serve with NGINX
# ==========================
FROM nginx:alpine

# Install envsubst
RUN apk add --no-cache gettext

# Copy React build
COPY --from=builder /app/build /usr/share/nginx/html

# Copy env-config.js template
COPY public/env-config.js /usr/share/nginx/html/env-config.js

# Copy nginx config
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

# Runtime substitution + start NGINX
CMD ["/bin/sh", "-c", "\
  echo 'Substituting environment variables...'; \
  envsubst < /usr/share/nginx/html/env-config.js > /usr/share/nginx/html/env-config.tmp && \
  mv /usr/share/nginx/html/env-config.tmp /usr/share/nginx/html/env-config.js && \
  nginx -g 'daemon off;'"]



=>run this command inside /frontend folder: docker build -t frontend-app .
=>run this command to create a container: docker run -d --name frontend --network akruti-network -p 80:80 frontend-app











=>run this to create a docker network:   docker network create akruti-network
=>run this command inside /backend folder
docker run -d   --name postgres-db   --network akruti-network   --env-file ./pg-cred   -v pgdb-data:/var/lib/postgresql/data   -v "$(pwd)/init.sql:/docker-entrypoint-initdb.d/init.sql"   -p 5432:5432   postgres:16


=>Now run this commands one by one inside /backend folder to create two admins
curl -X POST http://localhost:3001/auth/register   -H "Content-Type: application/json"   -d '{
 "username": "admin",
 "email": "admin@akrutimedia.com",
 "password": "admin@akruti",
 "firstName": "Akruti",
 "lastName": "Media",
 "role": "admin"
 }'


curl -X POST http://localhost:3001/auth/register   -H "Content-Type: application/json"   -d '{
 "username": "debi",
 "email": "debi@akrutimedia.com",
 "password": "debi@akruti",
 "firstName": "Debi",
 "lastName": "Prasad",
 "role": "admin"
 }'


==========================================================================================================================================================================================================================================

=>To check what inside the postgres-db container run these commands
docker exec -it postgres-db bash

psql -U debi -d akrutidev

\dt

SELECT * FROM articles;

SELECT * FROM users;


\d articles  or  \d  users   :to check the table structure


=>To take backup of the database run these two commands:   
docker exec postgres-db   
pg_dump -U debi akrutidev > pg_backup.sql


=>To restore the backup into that container or other conatiner
docker exec -i postgres-db 
psql -U debi -d akrutidev < pg_backup.sql

==========================================================================================================================================================================================================================================

=>To create a crontab for taking auto backup with 7 days roation do these steps:
-create a folder here:   mkdir -p /home/ubuntu/News-App-Backup
-create script & paste the code here & make it executable:  vim News-App-Backup/backup.sh
#!/bin/bash

# ==== CONFIG ====
BACKUP_DIR="/home/ubuntu/News-App-Backup"
CONTAINER_NAME="postgres-db"
DB_USER="debi"
DB_NAME="akrutidev"
RETENTION_DAYS=7
# ================

TIMESTAMP=$(date +"%Y-%m-%d_%H-%M-%S")
BACKUP_FILE="$BACKUP_DIR/backup_$TIMESTAMP.sql"

# Take pg_dump backup
docker exec $CONTAINER_NAME pg_dump -U $DB_USER $DB_NAME > "$BACKUP_FILE"

# Delete old backups (keep recent 7 days)
cd "$BACKUP_DIR"
ls -t | sed -e "1,${RETENTION_DAYS}d" | xargs -r rm --

-create a cronjob and paste it to run it in evryday at 1AM:    crontab -e
0 1 * * * /home/ubuntu/News-App-Backup/backup.sh >/dev/null 2>&1

=>Now to restore the backup run these command one by one
-go inside the pg container:  docker exec -it pg_container bash
-login inside it:  psql -U debi -d akrutidev
-run it to restore the latest backup:   psql -U debi -d akrutidev < /home/ubuntu/News-App-Backup/db_backup_2025-11-30.sql











==========================================================================================================================================================================================================================================
===============================================docker-build-versioning.yml====================================================

üëâ Build ONLY if corresponding folder changed.
üëâ No build if no code changed.
üëâ This includes:

‚úî Always build after version bump
‚úî Semantic versioning (major/minor/patch)
‚úî Start from v1.0.0
‚úî Smart folder change detection
‚úî Docker multi-arch builds
‚úî Advanced Color Output
‚úî Backend/Frontend build status
‚úî Build duration tracking
‚úî Everything production perfect

File: .github/workflows/docker-build-SMART.yml


name: Versioned Docker Build (Always Build After Version Bump)


on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  IMAGE_NAMESPACE: ${{ secrets.DOCKERHUB_USERNAME }}

jobs:
  version-and-build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:

      # 0Ô∏è‚É£ Record Workflow Start Time
      - name: Record workflow start time
        run: echo "GITHUB_WORKFLOW_STARTED_AT=$(date +%s)" >> $GITHUB_ENV

      # 1Ô∏è‚É£ Checkout
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 2Ô∏è‚É£ Bulletproof Folder Change Detection
      - name: Detect changed folders
        run: |
          echo "Comparing commits:"
          echo "Before: ${{ github.event.before }}"
          echo "After:  ${{ github.sha }}"

          CHANGED=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
          echo "Changed files:"
          echo "$CHANGED"

          if echo "$CHANGED" | grep -q "^frontend/"; then
            echo "FRONTEND_CHANGED=true" >> $GITHUB_ENV
          else
            echo "FRONTEND_CHANGED=false" >> $GITHUB_ENV
          fi

          if echo "$CHANGED" | grep -q "^backend/"; then
            echo "BACKEND_CHANGED=true" >> $GITHUB_ENV
          else
            echo "BACKEND_CHANGED=false" >> $GITHUB_ENV
          fi

      # 3Ô∏è‚É£ Get latest tag
      - name: Get tag
        run: |
          TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
          echo "LATEST_TAG=$TAG" >> $GITHUB_ENV
          echo "Latest Tag: $TAG"

      # 4Ô∏è‚É£ Extract version parts
      - name: Extract version
        run: |
          CLEAN=${LATEST_TAG#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CLEAN"
          echo "MAJOR=$MAJOR" >> $GITHUB_ENV
          echo "MINOR=$MINOR" >> $GITHUB_ENV
          echo "PATCH=$PATCH" >> $GITHUB_ENV

      # 5Ô∏è‚É£ Detect bump type
      - name: Detect bump
        run: |
          MSG=$(git log -1 --pretty=%s)
          echo "Commit Message: $MSG"

          if echo "$MSG" | grep -q major; then 
            echo "BUMP=major" >> $GITHUB_ENV
          elif echo "$MSG" | grep -q minor; then 
            echo "BUMP=minor" >> $GITHUB_ENV
          elif echo "$MSG" | grep -q patch; then 
            echo "BUMP=patch" >> $GITHUB_ENV
          else 
            echo "BUMP=none" >> $GITHUB_ENV
          fi

      # 6Ô∏è‚É£ Calculate new version
      - name: Calculate new version
        run: |
          if [[ "$BUMP" == "major" ]]; then 
            NEW_VERSION="v$((MAJOR+1)).0.0"
          elif [[ "$BUMP" == "minor" ]]; then 
            NEW_VERSION="v$MAJOR.$((MINOR+1)).0"
          elif [[ "$BUMP" == "patch" ]]; then 
            NEW_VERSION="v$MAJOR.$MINOR.$((PATCH+1))"
          else 
            NEW_VERSION="$LATEST_TAG"
          fi

          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV

      # 7Ô∏è‚É£ Create tag (only if bump)
      - name: Push tag
        if: ${{ env.BUMP != 'none' }}
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
          git push origin "$NEW_VERSION"

      # 8Ô∏è‚É£ Setup Docker
      - name: Setup Docker
        run: echo "Initializing Docker build system..."

      - name: QEMU
        uses: docker/setup-qemu-action@v3

      - name: Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 9Ô∏è‚É£ Build Backend Image (only if backend changed)
      - name: Build Backend
        if: ${{ env.BACKEND_CHANGED == 'true' }}
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.IMAGE_NAMESPACE }}/backend:${{ env.NEW_VERSION }}
            ${{ env.IMAGE_NAMESPACE }}/backend:latest

      # üîü Build Frontend Image (only if frontend changed)
      - name: Build Frontend
        if: ${{ env.FRONTEND_CHANGED == 'true' }}
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.IMAGE_NAMESPACE }}/frontend:${{ env.NEW_VERSION }}
            ${{ env.IMAGE_NAMESPACE }}/frontend:latest

      # 1Ô∏è‚É£1Ô∏è‚É£ Advanced Final Output Summary
      - name: Final output (Advanced)
        run: |
          echo ""
          echo "=============================="
          echo "  üöÄ BUILD SUMMARY REPORT"
          echo "=============================="
          echo ""
          echo -e "üéØ Current Version:    ${LATEST_TAG}"
          echo -e "üéØ New Version:        ${NEW_VERSION}"
          echo -e "üéØ Bump Type:          ${BUMP}"
          echo ""

          if [[ "${BACKEND_CHANGED}" == "true" ]]; then
            echo -e "üõ†Ô∏è Backend Built: YES"
            echo -e "     ‚Üí backend:${NEW_VERSION}"
            echo -e "     ‚Üí backend:latest"
          else
            echo -e "üõ†Ô∏è Backend Built: NO (no changes)"
          fi
          echo ""

          if [[ "${FRONTEND_CHANGED}" == "true" ]]; then
            echo -e "üõ†Ô∏è Frontend Built: YES"
            echo -e "     ‚Üí frontend:${NEW_VERSION}"
            echo -e "     ‚Üí frontend:latest"
          else
            echo -e "üõ†Ô∏è Frontend Built: NO (no changes)"
          fi
          echo ""

          END_TIME=$(date +%s)
          DURATION=$((END_TIME - GITHUB_WORKFLOW_STARTED_AT))
          echo -e "‚è±Ô∏è Total Build Time: ${DURATION} seconds"
          echo ""
          echo "=============================="
          echo "üéâ BUILD COMPLETED SUCCESSFULLY"
          echo "=============================="






=====================================================================================================================================================================================================================================================================================TAKE BACKUP AND PUSH TO GITHUB===================================================

=>Create a github repo named AkrutiMediaBackup
=>Now run git clone <you_github_repo_link>  inside /home/ubuntu/    so that it will pull that empty repo inside your ubuntu machine
=>Setup git credential in ubuntu machine to work backup push
=>Now create all these 4 backup-script inside your ubuntu machine here:  /home/ubuntu/AkrutiMediaBackup  and MAKE SURE YOU HAVE GIVEN FULL PERMISSION TO ALL THESE 4 SCRIPTS i.e   chmod 777 <backup-script-name>

=>Create a backup script named daily-backup.sh and past this code
#!/bin/bash

##############################################
# DAILY BACKUP SCRIPT
# - Takes daily backup at 1 AM
# - Stores inside Daily-Backup folder
# - Keeps latest 3 backups only
# - Pushes changes to GitHub repository
##############################################

# ==== CONFIG ====
BASE_DIR="/home/ubuntu/News-App-Backup"
BACKUP_DIR="$BASE_DIR/Daily-Backup"
CONTAINER_NAME="postgres-db"
DB_USER="debi"
DB_NAME="akrutidev"
RETENTION_COUNT=3
# ================

# Ensure folder exists
mkdir -p "$BACKUP_DIR"

# Timestamp for filename
TIMESTAMP=$(date +"%Y-%m-%d_%H-%M-%S")
BACKUP_FILE="$BACKUP_DIR/daily_backup_$TIMESTAMP.sql"

# Take PostgreSQL backup from Docker container
docker exec $CONTAINER_NAME pg_dump -U $DB_USER $DB_NAME > "$BACKUP_FILE"

# Move into backup directory for rotation
cd "$BACKUP_DIR"

# Delete files except the latest 3
ls -t | sed -e "1,${RETENTION_COUNT}d" | xargs -r rm --

# ==== PUSH TO GITHUB ====
cd "$BASE_DIR"
git add .
git commit -m "Daily backup update: $TIMESTAMP" >/dev/null 2>&1
git push origin main

=>Set cronjob by adding this command to run this script at everyday at 1AM
0 1 * * * /home/ubuntu/News-App-Backup/daily-backup.sh >> /home/ubuntu/News-App-Backup/daily.log 2>&1


=>Now Create a backup script named weekly-backup.sh and past this code
#!/bin/bash

##############################################
# WEEKLY BACKUP SCRIPT
# - Runs every Monday at 1 AM
# - Stores inside Weekly-Backup folder
# - Keeps only latest 1 weekly backup
# - Pushes updated folder to GitHub
##############################################

# ==== CONFIG ====
BASE_DIR="/home/ubuntu/News-App-Backup"
BACKUP_DIR="$BASE_DIR/Weekly-Backup"
CONTAINER_NAME="postgres-db"
DB_USER="debi"
DB_NAME="akrutidev"
RETENTION_COUNT=1
# ================

mkdir -p "$BACKUP_DIR"

# Year + Week number
TIMESTAMP=$(date +"%Y-W%U")
BACKUP_FILE="$BACKUP_DIR/weekly_backup_$TIMESTAMP.sql"

docker exec $CONTAINER_NAME pg_dump -U $DB_USER $DB_NAME > "$BACKUP_FILE"

cd "$BACKUP_DIR"

# Keep only 1 file
ls -t | sed -e "1,${RETENTION_COUNT}d" | xargs -r rm --

# ==== PUSH TO GITHUB ====
cd "$BASE_DIR"
git add .
git commit -m "Weekly backup update: $TIMESTAMP" >/dev/null 2>&1
git push origin main

=>Set cronjob by adding this command to run this script every week
0 1 * * 1 /home/ubuntu/News-App-Backup/weekly-backup.sh >> /home/ubuntu/News-App-Backup/weekly.log 2>&1



=>Now Create a backup script named monthly-backup.sh and past this code
#!/bin/bash

##############################################
# MONTHLY BACKUP SCRIPT
# - Runs on 1st of each month at 1 AM
# - Stores inside Monthly-Backup
# - Keeps only latest 1 monthly backup
# - Pushes updated folder to GitHub
##############################################

# ==== CONFIG ====
BASE_DIR="/home/ubuntu/News-App-Backup"
BACKUP_DIR="$BASE_DIR/Monthly-Backup"
CONTAINER_NAME="postgres-db"
DB_USER="debi"
DB_NAME="akrutidev"
RETENTION_COUNT=1
# ================

mkdir -p "$BACKUP_DIR"

# Year-Month format
TIMESTAMP=$(date +"%Y-%m")
BACKUP_FILE="$BACKUP_DIR/monthly_backup_$TIMESTAMP.sql"

docker exec $CONTAINER_NAME pg_dump -U $DB_USER $DB_NAME > "$BACKUP_FILE"

cd "$BACKUP_DIR"

# Keep only latest file
ls -t | sed -e "1,${RETENTION_COUNT}d" | xargs -r rm --

# ==== PUSH TO GITHUB ====
cd "$BASE_DIR"
git add .
git commit -m "Monthly backup update: $TIMESTAMP" >/dev/null 2>&1
git push origin main


=>Set cronjob by adding this command to run this script every month
0 1 1 * * /home/ubuntu/News-App-Backup/monthly-backup.sh >> /home/ubuntu/News-App-Backup/monthly.log 2>&1



=>Now Create a backup script named quaterlybackup.sh and past this code
#!/bin/bash

##############################################
# QUARTERLY BACKUP SCRIPT
# - Runs every 3 months at 1 AM
# - Stores inside Quaterly-Backup folder
# - Keeps only latest 1 quarterly backup
# - Pushes updated folder to GitHub
##############################################

# ==== CONFIG ====
BASE_DIR="/home/ubuntu/News-App-Backup"
BACKUP_DIR="$BASE_DIR/Quaterly-Backup"
CONTAINER_NAME="postgres-db"
DB_USER="debi"
DB_NAME="akrutidev"
RETENTION_COUNT=1
# ================

mkdir -p "$BACKUP_DIR"

# Determine quarter number (1‚Äì4)
MONTH=$(date +"%m")
QUARTER=$(( ( (MONTH - 1) / 3 ) + 1 ))
TIMESTAMP=$(date +"%Y-Q$QUARTER")

BACKUP_FILE="$BACKUP_DIR/quaterly_backup_$TIMESTAMP.sql"

docker exec $CONTAINER_NAME pg_dump -U $DB_USER $DB_NAME > "$BACKUP_FILE"

cd "$BACKUP_DIR"

# Keep latest 1 quarterly file
ls -t | sed -e "1,${RETENTION_COUNT}d" | xargs -r rm --

# ==== PUSH TO GITHUB ====
cd "$BASE_DIR"
git add .
git commit -m "Quarterly backup update: $TIMESTAMP" >/dev/null 2>&1
git push origin main

=>Set cronjob by adding this command to run this script every quater
0 1 1 */3 * /home/ubuntu/News-App-Backup/quaterly-backup.sh >> /home/ubuntu/News-App-Backup/quaterly.log 2>&1




=>Now configure Git to Push Without Password so Generate SSH Key on Server
ssh-keygen -t backup_script_id

This creates:
~/.ssh/backup_script_id
~/.ssh/backup_script_id.pub

=>Show the public key
cat ~/.ssh/id_ed25519.pub

=>Copy that entire key & Add it to GitHub
Go to:
GitHub ‚Üí Settings ‚Üí SSH Keys ‚Üí Add New Key
Paste the key ‚Üí Save.

=>Test connection:
ssh -T git@github.com

If it says:
Hi your-username! You've successfully authenticated.
Then git push will work automatically.

=>Now Set Git User Details on Server
git config --global user.name "your-name"
git config --global user.email "your-email@example.com"


=>Now one time run this script manually to test it is creating the respective backup folder with backup file or not & pushing it to github repo or not
